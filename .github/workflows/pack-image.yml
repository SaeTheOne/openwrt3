name: 📦 Pack OpenWrt Image

on:
  workflow_call:
    inputs:
      rootfs_url:
        description: '远程 rootfs 下载 URL（可选）'
        required: false
        type: string
      rootfs_path:
        description: '构建生成的 rootfs 路径（用于同仓调用时的提示，仅用于日志）'
        required: false
        type: string
      whoami_content:
        description: 'openwrt_packit 的 whoami 文件内容（可选）'
        required: false
        type: string
      kernel_base_url:
        description: '内核 tarball 基础 URL（默认为 SaeTheOne/openwrt3 flippy_kernel）'
        required: false
        type: string
  workflow_dispatch:
    inputs:
      rootfs_url:
        description: '远程 rootfs 下载 URL（可选）'
        required: false
        default: ''
      whoami_content:
        description: 'openwrt_packit 的 whoami 文件内容（可选）'
        required: false
        default: ''
      kernel_base_url:
        description: '内核 tarball 基础 URL（默认为 SaeTheOne/openwrt3 flippy_kernel）'
        required: false
        default: 'https://raw.githubusercontent.com/SaeTheOne/openwrt3/main/flippy_kernel'

jobs:
  pack:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout openwrt_packit
        uses: actions/checkout@v4
        with:
          repository: unifreq/openwrt_packit
          path: ./openwrt_packit

      - name: Write whoami file
        run: |
          if [ -n "${{ inputs.whoami_content }}" ]; then
            CONTENT="${{ inputs.whoami_content }}"
            printf "%s\n" "$CONTENT" > ./openwrt_packit/whoami
          else
            # 从调用仓库默认分支拉取 whoami（如失败则保持空）
            REPO="${GITHUB_REPOSITORY}"
            BRANCH="main"
            URL="https://raw.githubusercontent.com/${REPO}/${BRANCH}/flippy_kernel/whoami"
            echo "尝试获取 whoami: $URL"
            curl -fsSL "$URL" -o ./openwrt_packit/whoami || true
          fi

          echo "当前 whoami 内容:"
          cat ./openwrt_packit/whoami || true

      - name: Prepare kernel files based on whoami
        env:
          KERNEL_BASE_URL: ${{ inputs.kernel_base_url }}
        run: |
          set -e
          KERNEL_VERSION=$(grep '^KERNEL_VERSION=' ./openwrt_packit/whoami | cut -d'=' -f2)
          if [ -z "$KERNEL_VERSION" ]; then
            echo "未在 whoami 中找到 KERNEL_VERSION"
            exit 1
          fi
          BASE_URL=${KERNEL_BASE_URL:-https://raw.githubusercontent.com/SaeTheOne/openwrt3/main/flippy_kernel}
          echo "使用内核版本: $KERNEL_VERSION"
          echo "内核来源: $BASE_URL"
          sudo mkdir -p /opt/kernel
          cd /tmp
          for f in \
            "boot-$KERNEL_VERSION.tar.gz" \
            "dtb-allwinner-$KERNEL_VERSION.tar.gz" \
            "dtb-amlogic-$KERNEL_VERSION.tar.gz" \
            "dtb-rockchip-$KERNEL_VERSION.tar.gz" \
            "header-$KERNEL_VERSION.tar.gz" \
            "modules-$KERNEL_VERSION.tar.gz"; do
            echo "下载: $BASE_URL/$f"
            curl -fsSL "$BASE_URL/$f" -o "$f"
            sudo cp "$f" /opt/kernel/
          done

      - name: Download rootfs from URL
        if: ${{ inputs.rootfs_url != '' }}
        run: |
          URL="${{ inputs.rootfs_url }}"
          echo "📥 从 URL 下载 rootfs: $URL"
          # 从URL中提取原始文件名，保留文件的原始名称
          ORIGINAL_NAME=$(basename "$URL")
          curl -fsSL "$URL" -o "$ORIGINAL_NAME"
          echo "ROOTFS_FILE=$ORIGINAL_NAME" >> $GITHUB_ENV

      - name: Download rootfs artifact (fallback)
        if: ${{ inputs.rootfs_url == '' }}
        uses: actions/download-artifact@v4
        with:
          path: ./artifact_rootfs
          pattern: "*.tar.gz"
          merge-multiple: true

      - name: Prepare rootfs from artifact
        if: ${{ inputs.rootfs_url == '' }}
        run: |
          set -e
          FILE=$(find ./artifact_rootfs -type f -name "*.tar.gz" | head -n1)
          if [ -z "$FILE" ]; then
            echo "❌ 未找到 rootfs artifact (*.tar.gz)"
            exit 1
          fi
          # 获取原始文件名
          ORIGINAL_NAME=$(basename "$FILE")
          echo "📁 原始rootfs文件名: $ORIGINAL_NAME"
          
          # 提取name1：删除-generic-rootfs.tar.gz部分
          NAME1=${ORIGINAL_NAME%-generic-rootfs.tar.gz}
          NAME1=${NAME1%-rootfs.tar.gz} # 额外处理可能的-rootfs.tar.gz后缀
          echo "✅ 提取的NAME1: $NAME1"
          
          # 复制文件并重命名为openwrt-armvirt-64-default-rootfs.tar.gz
          cp "$FILE" "openwrt-armvirt-64-default-rootfs.tar.gz"
          echo "ROOTFS_FILE=openwrt-armvirt-64-default-rootfs.tar.gz" >> $GITHUB_ENV
          echo "NAME1=$NAME1" >> $GITHUB_ENV
          
          # 显示文件信息
          ls -la "openwrt-armvirt-64-default-rootfs.tar.gz"

      - name: Mirror rootfs into tmp directory (compat)
        run: |
          mkdir -p tmp
          cp -f "${{ env.ROOTFS_FILE }}" tmp/
          echo "✅ Rootfs文件已复制到tmp目录: tmp/${{ env.ROOTFS_FILE }}"

      - name: Record rootfs metadata
        run: |
          if [ -n "${{ inputs.rootfs_url }}" ]; then
            ORIGINAL_NAME=$(basename "${{ inputs.rootfs_url }}")
          else
            ORIGINAL_NAME=$(basename $(find ./artifact_rootfs -type f -name "*.tar.gz" | head -n1))
          fi
          KERNEL_VERSION=$(grep '^KERNEL_VERSION=' ./openwrt_packit/whoami | cut -d'=' -f2)
          {
            echo "original_rootfs_name=$ORIGINAL_NAME";
            echo "kernel_version=$KERNEL_VERSION";
            echo "whoami:";
            cat ./openwrt_packit/whoami;
          } > rootfs-meta.txt
          BASE=${ORIGINAL_NAME%.tar.gz}
          BASE=${BASE%-generic-rootfs}
          BASE=${BASE%-rootfs}
          echo "PACKED_ARTIFACT_NAME=${BASE}-packed-image" >> $GITHUB_ENV

      - name: Upload rootfs metadata
        uses: actions/upload-artifact@v4
        with:
          name: openwrt-rootfs-for-packing-meta
          path: rootfs-meta.txt

      - name: 准备打包环境
        run: |
          # 确保使用bash执行脚本，而不是默认的dash
          echo "SHELL=$(which bash)" >> $GITHUB_ENV
          
          # 检查openwrt_packit目录结构
          echo "📂 openwrt_packit目录内容:"
          ls -la ./openwrt_packit
          
          # 给所有脚本添加执行权限
          chmod +x ./openwrt_packit/*.sh
          
          # 检查是否存在其他必要的脚本文件
          echo "🔍 检查必要的脚本文件:"
          ls -la ./openwrt_packit/lib/ 2>/dev/null || echo "lib目录不存在"
      
      - name: Run packing script
        working-directory: ./openwrt_packit
        shell: bash {0}  # 显式使用bash执行脚本
        run: |
          ROOTFS_FILE="${{ env.ROOTFS_FILE }}"
          NAME1="${{ env.NAME1 }}"
          TODAY_DATE=$(date +"%Y%m%d")
          echo "📦 Packing image using: ../$ROOTFS_FILE"
          echo "📝 NAME1: $NAME1, 日期: $TODAY_DATE"
          
          # 关键调试：显示详细的目录结构信息
          echo "📁 当前工作目录: $(pwd)"
          echo "📁 上级目录: $(cd .. && pwd)"
          echo "📁 根目录: /"
          echo "📁 环境变量GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          
          # 显示目录层次结构
          echo "📂 目录层次结构:"
          find .. -type d -maxdepth 2 | sort
          
          # 确保临时目录不存在
          sudo rm -rf tmp/* 2>/dev/null || true
          mkdir -p tmp
          
          # 检查rootfs文件是否存在并显示详细信息
          echo "🔍 检查rootfs文件: ../$ROOTFS_FILE"
          if [ -f "../$ROOTFS_FILE" ]; then
            echo "✅ 文件存在，大小: $(du -h ../$ROOTFS_FILE | cut -f1)"
          else
            echo "❌ 文件不存在！正在搜索所有可用的tar.gz文件..."
            find .. -name "*.tar.gz" -type f | xargs ls -la
          fi
          
          # 复制rootfs到openwrt_packit的tmp目录
          cp -f ../$ROOTFS_FILE tmp/ || echo "❌ 复制文件失败！"
          
          # 关键修复：创建脚本期望的多个rootfs文件名副本
          # 从错误信息看，脚本可能在寻找特定命名的rootfs文件
          ROOTFS_BASENAME=$(basename "$ROOTFS_FILE")
          
          # 复制到多个可能的位置和名称，确保脚本能找到
          cp -f ../$ROOTFS_FILE tmp/rootfs.tar.gz      # 最基础的名称
          cp -f ../$ROOTFS_FILE tmp/openwrt_rootfs.tar.gz  # 可能的默认名称
          cp -f ../$ROOTFS_FILE tmp/openwrt-armvirt-64-rootfs.tar.gz  # 架构相关名称
          cp -f ../$ROOTFS_FILE ./tmp/openwrt_rootfs.tar.gz  # 当前目录下的tmp目录
          cp -f ../$ROOTFS_FILE ./rootfs.tar.gz  # 直接复制到当前目录
          
          # 显示tmp目录内容，用于调试
          echo "📂 tmp目录内容:"
          ls -la tmp/
          echo "📂 当前目录内容:"
          ls -la
          
          # 修改mk_s905d_n1.sh脚本，确保mkdir命令使用-p参数
          sed -i 's/mkdir /mkdir -p /g' ./mk_s905d_n1.sh
          
          # 显示get_openwrt_rootfs_archive函数的实现，帮助诊断
          echo "🔍 get_openwrt_rootfs_archive函数实现:"
          grep -n -A 20 "get_openwrt_rootfs_archive" ./mk_s905d_n1.sh || echo "未找到get_openwrt_rootfs_archive函数"
          
          # 给脚本添加执行权限
          chmod +x ./mk_s905d_n1.sh
          
          # 关键修复：直接使用实际的rootfs文件路径
          ACTUAL_ROOTFS_PATH="${PWD}/../openwrt-armvirt-64-default-rootfs.tar.gz"
          echo "🔧 在mk_s905d_n1.sh脚本开头设置OPWRT_ROOTFS_GZ=$ACTUAL_ROOTFS_PATH"
          
          # 检查并创建必要的目录
          mkdir -p lib tmp output
          
          # 检查是否存在必要的库文件
          if [ ! -f ./lib/_common.sh ]; then
            echo "⚠️  _common.sh文件不存在，尝试从仓库获取..."
            # 从unifreq/openwrt_packit仓库下载必要的库文件
            curl -fsSL "https://raw.githubusercontent.com/unifreq/openwrt_packit/main/lib/_common.sh" -o ./lib/_common.sh || echo "❌ 下载_common.sh失败"
          fi
          
          # 确保所有库文件都有执行权限
          chmod +x ./lib/*.sh 2>/dev/null || true
          
          # 修改脚本使用bash执行
          sed -i '1i #!/bin/bash' ./mk_s905d_n1.sh
          
          # 在脚本开头设置OPWRT_ROOTFS_GZ变量
          sed -i '1i OPWRT_ROOTFS_GZ="'"$ACTUAL_ROOTFS_PATH"'"' ./mk_s905d_n1.sh
          
          # 同时保留环境变量设置，双重保险
          export OPWRT_ROOTFS_GZ="$ACTUAL_ROOTFS_PATH"
          echo "🔧 设置环境变量OPWRT_ROOTFS_GZ=$OPWRT_ROOTFS_GZ"
          
          # 在脚本内部也添加OPWRT_ROOTFS_GZ变量检查和设置
          # 找到get_openwrt_rootfs_archive函数并在其中添加直接返回变量值的逻辑
          if grep -q "get_openwrt_rootfs_archive" ./mk_s905d_n1.sh; then
            echo "🔧 修改get_openwrt_rootfs_archive函数，优先使用OPWRT_ROOTFS_GZ环境变量"
            # 在函数开头添加检查OPWRT_ROOTFS_GZ变量的逻辑
            sed -i '/get_openwrt_rootfs_archive()/a \    if [ -n "$OPWRT_ROOTFS_GZ" ] && [ -f "$OPWRT_ROOTFS_GZ" ]; then\n        echo "$OPWRT_ROOTFS_GZ"\n        return 0\n    fi' ./mk_s905d_n1.sh
          fi
          
          # 直接修改脚本，在任何地方查找rootfs文件前都先检查OPWRT_ROOTFS_GZ
          echo "🔧 在脚本中添加全局rootfs路径检查"
          # 在脚本开头添加多个rootfs路径的检查和设置
          cat << 'EOF' > ./rootfs_finder.sh
          #!/bin/bash
          
          # 查找rootfs文件的所有可能位置
          check_rootfs_location() {
              local locations=("$1" "../openwrt-armvirt-64-default-rootfs.tar.gz" "./openwrt_rootfs.tar.gz" "./rootfs.tar.gz" "tmp/rootfs.tar.gz" "tmp/openwrt_rootfs.tar.gz")
              
              for loc in "${locations[@]}"; do
                  if [ -f "$loc" ]; then
                      echo "✅ 找到rootfs文件在: $loc"
                      return 0
                  fi
              done
              
              return 1
          }
          
          # 运行检查
          if ! check_rootfs_location "$OPWRT_ROOTFS_GZ"; then
              echo "❌ 未找到rootfs文件! 尝试复制当前位置的文件..."
              # 尝试从上级目录复制
              cp -f ../openwrt-armvirt-64-default-rootfs.tar.gz ./openwrt_rootfs.tar.gz 2>/dev/null || echo "复制失败"
              cp -f ../openwrt-armvirt-64-default-rootfs.tar.gz ./rootfs.tar.gz 2>/dev/null || echo "复制失败"
          fi
          EOF
          
          chmod +x ./rootfs_finder.sh
          
          # 显示修改后的脚本开头几行，确认设置成功
          echo "📝 修改后的脚本开头几行:"
          head -n 15 ./mk_s905d_n1.sh
          
          # 精确调试：检查执行时的环境变量值
          echo "🔍 执行前环境变量检查:"
          env | grep -E 'OPWRT|ROOTFS|SHELL'
          echo "🔍 实际rootfs文件路径检查:"
          ls -la "$ACTUAL_ROOTFS_PATH" || echo "文件不存在"
          echo "🔍 上级目录文件检查:"
          ls -la ../ | grep rootfs
          
          # 检查库文件是否存在
          echo "📁 检查库文件:"
          ls -la ./lib/ 2>/dev/null || echo "lib目录不存在或为空"
          
          # 安装必要的依赖
          echo "📦 安装必要的依赖..."
          sudo apt-get update
          sudo apt-get install -y btrfs-progs dosfstools mtools parted squashfs-tools
          
          # 运行打包脚本，添加调试输出
          echo "🚀 运行打包脚本..."
          SCRIPT_EXIT_CODE=0
          # 运行rootfs查找脚本
          ./rootfs_finder.sh
          
          # 额外设置环境变量并传递给sudo
          echo "🔧 使用sudo -E确保环境变量正确传递"
          sudo -E OPWRT_ROOTFS_GZ="$ACTUAL_ROOTFS_PATH" bash ./mk_s905d_n1.sh _test 2>&1 | tee packing.log || SCRIPT_EXIT_CODE=$?
          
          echo "📊 打包脚本执行状态码: $SCRIPT_EXIT_CODE"
          
          # 显示packing.log的关键部分，帮助诊断错误
          echo "📝 打包日志关键信息:" 
          grep -E 'error|failed|not found|warning' packing.log || echo "未发现明显错误信息"
          
          # 显示当前目录结构，查看所有可能的输出位置
          echo "📂 当前目录结构:" 
          find . -type f -name "*.img" 2>/dev/null || echo "未找到任何.img文件"
          
          # 检查所有可能的输出目录
          echo "📂 检查所有可能的输出位置:" 
          ls -la ./ 2>/dev/null
          ls -la ./output/ 2>/dev/null || echo "output目录不存在"
          ls -la ./tmp/ 2>/dev/null || echo "tmp目录不存在"
          
          # 重点：只在output目录下搜索生成的镜像文件
          echo "🔍 在output目录下搜索生成的img文件..."
          mkdir -p output  # 确保output目录存在
          
          # 优先在output目录下查找大的镜像文件
          IMG_FILE=$(find ./output -name "*.img" -type f -size +100M 2>/dev/null | head -n 1)
          
          # 如果output目录下没找到大的img文件，尝试查找output目录下的任何img文件
          if [ -z "$IMG_FILE" ]; then
            echo "⚠️  在output目录下未找到大的img文件，尝试查找output目录下的任何img文件..."
            IMG_FILE=$(find ./output -name "*.img" -type f 2>/dev/null | head -n 1)
          fi
          
          # 输出output目录的详细内容，帮助调试
          echo "📁 output目录内容详情："
          ls -la ./output/
          
          if [ -n "$IMG_FILE" ]; then
            echo "✅ 找到img文件: $IMG_FILE"
            # 重命名img文件为name1+日期+.img格式
            NEW_IMG_NAME="${NAME1}-${TODAY_DATE}.img"
            cp "$IMG_FILE" "output/$NEW_IMG_NAME"
            echo "✅ 已重命名img文件: $NEW_IMG_NAME"
            echo "FINAL_IMG_NAME=$NEW_IMG_NAME" >> $GITHUB_ENV
          else
            echo "❌ 未找到生成的img文件"
            # 即使失败也尝试继续，以便上传调试信息
            echo "⚠️  尝试继续执行以收集更多调试信息..."
          fi


      - name: Upload packed image(s)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.FINAL_IMG_NAME || 'packed-image' }}
          path: ./openwrt_packit/output/${{ env.FINAL_IMG_NAME || '*.img' }}
          if-no-files-found: error
